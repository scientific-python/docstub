"""Utilities to work with Python packages on the file system."""

import logging
import re
import sys
from functools import lru_cache

if sys.version_info >= (3, 13):
    from glob import translate as glob_translate
else:
    from ._vendored.stdlib import glob_translate


logger = logging.getLogger(__name__)


STUB_HEADER_COMMENT = "# File generated with docstub"


def is_docstub_generated(path):
    """Check if the stub file was generated by docstub.

    Parameters
    ----------
    path : Path

    Returns
    -------
    is_generated : bool
    """
    assert path.suffix == ".pyi"
    with path.open("r") as fo:
        content = fo.read()
    if re.match(f"^{re.escape(STUB_HEADER_COMMENT)}", content):
        return True
    return False


def is_python_package(path):
    """
    Parameters
    ----------
    path : Path

    Returns
    -------
    is_package : bool

    Examples
    --------
    >>> from pathlib import Path
    >>> is_python_package(Path(__file__))
    False
    >>> is_python_package(Path(__file__).parent)
    True
    >>> is_python_package(Path(__file__).parent.parent)
    False
    """
    has_init = (path / "__init__.py").is_file() or (path / "__init__.pyi").is_file()
    is_package = path.is_dir() and has_init
    return is_package


def find_package_root(path):
    """Determine the root a Python package from any path pointing inside it.

    Parameters
    ----------
    path : Path

    Returns
    -------
    package_root : Path

    Examples
    --------
    >>> from pathlib import Path
    >>> package_root = find_package_root(Path(__file__))
    >>> (package_root / "docstub").is_dir()
    True
    """
    root = path
    if root.is_file():
        root = root.parent

    for _ in range(2**16):
        if not is_python_package(root):
            logger.debug("detected %s as the package root of %s", root, path)
            return root
        root = root.parent

    msg = f"exceeded iteration length while trying to find package root for {path}"
    raise RuntimeError(msg)


@lru_cache(maxsize=10)
def glob_patterns_to_regex(patterns, relative_to=None):
    r"""Combine glob-style patterns into a single regex.

    Parameters
    ----------
    patterns : tuple of (str, ...), optional
    relative_to : Path, optional

    Returns
    -------
    regex : re.Pattern | None

    Examples
    --------
    >>> from pathlib import Path
    >>> glob_patterns_to_regex(("**/tests", "**/test_*.py"))
    re.compile('(?s:(?:.+/)?tests)\\Z|(?s:(?:.+/)?test_[^/]*\\.py)\\Z')

    Use `relative_to` to make patterns absolute:

    >>> glob_patterns_to_regex(("**/tests",), relative_to=Path(__file__).parent)
    re.compile('(?s:/.../docstub/(?:.+/)?tests)\\Z')

    A glob prefixed with "/" isn't normalized with `relative_to`:

    >>> glob_patterns_to_regex(("/**/tests",), relative_to=Path(__file__).parent)
    re.compile('(?s:/(?:.+/)?tests)\\Z')
    """
    if relative_to:

        def prefix(pattern):
            return str((relative_to / pattern).resolve())

        patterns = tuple(
            pattern if pattern.startswith("/") else prefix(pattern)
            for pattern in patterns
        )

    if len(patterns) == 0:
        return None
    translated = (
        glob_translate(pattern, recursive=True, include_hidden=True)
        for pattern in patterns
    )
    joined = "|".join(translated)
    regex = re.compile(f"{joined}")
    return regex


def walk_python_package(root_dir, *, ignore=()):
    """Iterate source files in a Python package.

    Given a Python package, yield the path of contained Python modules. If an
    alternate stub file already exists and isn't generated by docstub, it is
    returned instead.

    Parameters
    ----------
    root_dir : Path
        Root directory of a Python package.
    ignore : Sequence[str], optional
        Don't yield files matching these glob-like patterns. The pattern is
        interpreted relative to the root of the Python package unless it starts
        with "/". See :ref:`glob.translate(..., recursive=True, include_hidden=True)`
        for more details on the precise implementation.

    Yields
    ------
    source_path : Path
        Either a Python file or a stub file that takes precedence.
    """
    package_root = find_package_root(root_dir)
    regex = glob_patterns_to_regex(tuple(ignore), relative_to=package_root)

    if regex and regex.match(str(root_dir)):
        logger.info("ignoring %s", root_dir)
        return

    for path in root_dir.iterdir():
        if regex and regex.match(str(path.resolve())):
            logger.info("ignoring %s", path)
            continue
        if path.is_dir():
            if is_python_package(path):
                yield from walk_python_package(path, ignore=ignore)
            else:
                logger.debug("skipping directory %s which isn't a Python package", path)
            continue

        assert path.is_file()
        suffix = path.suffix.lower()

        if suffix == ".py":
            stub = path.with_suffix(".pyi")
            if stub.exists() and not is_docstub_generated(stub):
                # Non-generated stub file already exists and takes precedence
                yield stub
            else:
                yield path


def walk_source_and_targets(root_path, target_dir, *, ignore=()):
    """Iterate modules in a Python package and its target stub files.

    Parameters
    ----------
    root_path : Path
        Root directory of a Python package or a single Python file.
    target_dir : Path
        Root directory in which a matching stub package will be created.
    ignore : Sequence[str], optional
        Don't yield files matching these glob-like patterns. The pattern is
        interpreted relative to the root of the Python package unless it starts
        with "/". See :ref:`glob.translate(..., recursive=True, include_hidden=True)`
        for more details on the precise implementation.

    Yields
    ------
    source_path : Path
        Either a Python file or a stub file that takes precedence.
    stub_path : Path
        Target stub file.
    """
    if root_path.is_file():
        stub_path = target_dir / root_path.with_suffix(".pyi").name
        yield root_path, stub_path
        return

    for source_path in walk_python_package(root_path, ignore=ignore):
        stub_path = target_dir / source_path.with_suffix(".pyi").relative_to(root_path)
        yield source_path, stub_path
