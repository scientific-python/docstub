"""Utilities to work with Python packages on the file system."""

import logging
import re
import sys
from functools import lru_cache

if sys.version_info >= (3, 13):
    from glob import translate as glob_translate
else:
    from ._vendored.stdlib import glob_translate


logger: logging.Logger = logging.getLogger(__name__)


STUB_HEADER_COMMENT: str = "# File generated with docstub"


def is_docstub_generated(stub_path):
    """Check if the stub file was generated by docstub.

    Parameters
    ----------
    stub_path : Path
        Path to a stub file.

    Returns
    -------
    is_generated : bool

    Examples
    --------
    >>> from pathlib import Path
    >>> from docstub import _version
    >>> is_docstub_generated(Path(_version.__file__).with_suffix(".pyi"))
    False

    >>> is_docstub_generated(Path(__file__))
    Traceback (most recent call last):
        ...
    TypeError: expected stub file (ending with '.pyi'), ...
    """
    if stub_path.suffix != ".pyi":
        raise TypeError(f"expected stub file (ending with '.pyi'), got {stub_path}")
    with stub_path.open("r") as fo:
        content = fo.read()
    if re.match(f"^{re.escape(STUB_HEADER_COMMENT)}", content):
        return True
    return False


def is_python_or_stub_file(path):
    """Check whether `path` is a Python source file.

    Parameters
    ----------
    path : Path

    Returns
    -------
    is_python_or_stub_file : bool

    See Also
    --------
    is_python_package_dir

    Examples
    --------
    >>> from pathlib import Path
    >>> is_python_or_stub_file(Path(__file__))
    True
    >>> is_python_or_stub_file(Path(__file__).parent)
    False
    """
    return path.is_file() and path.suffix in (".py", ".pyi")


def is_python_package_dir(path):
    """Check whether `path` is a valid Python package and a directory.

    Parameters
    ----------
    path : Path

    Returns
    -------
    is_package : bool

    See Also
    --------
    is_python_or_stub_file

    Examples
    --------
    >>> from pathlib import Path
    >>> is_python_package_dir(Path(__file__))
    False
    >>> is_python_package_dir(Path(__file__).parent)
    True
    >>> is_python_package_dir(Path(__file__).parent.parent)
    False
    """
    has_init = (path / "__init__.py").is_file() or (path / "__init__.pyi").is_file()
    is_package = path.is_dir() and has_init
    return is_package


def find_package_root(path):
    """Determine the root of a Python package from any path pointing inside it.

    Parameters
    ----------
    path : Path

    Returns
    -------
    package_root : Path

    Examples
    --------
    >>> from pathlib import Path
    >>> package_root = find_package_root(Path(__file__))
    >>> package_root.name
    'docstub'

    >>> find_package_root(package_root) == package_root
    True
    """
    root = path.resolve()  # `Path.parent` can't move past relative "." part

    for _ in range(2**16):
        parent = root.parent
        assert parent
        if not is_python_package_dir(parent):
            logger.debug("Detected %s as the package root of %s", root, path)
            return root
        root = parent

    msg = f"exceeded iteration length while trying to find package root for {path}"
    raise RuntimeError(msg)


@lru_cache(maxsize=10)
def glob_patterns_to_regex(patterns, relative_to=None):
    r"""Combine glob-style patterns into a single regex [1].

    Parameters
    ----------
    patterns : tuple of (str, ...), optional
    relative_to : Path, optional

    Returns
    -------
    regex : re.Pattern | None

    References
    ----------
    .. [1] https://docs.python.org/3/library/glob.html#glob.translate

    Examples
    --------
    >>> from pathlib import Path
    >>> glob_patterns_to_regex(("**/tests", "**/test_*.py"))  # doctest: +SKIP
    re.compile('(?s:(?:.+/)?tests)\\Z|(?s:(?:.+/)?test_[^/]*\\.py)\\Z')

    Use `relative_to` to make patterns absolute:

    >>> glob_patterns_to_regex(("**/tests",), relative_to=Path(__file__).parent  # doctest: +SKIP
    re.compile('(?s:/.../docstub/(?:.+/)?tests)\\Z')

    A glob prefixed with "/" isn't normalized with `relative_to`:

    >>> glob_patterns_to_regex(("/**/tests",), relative_to=Path(__file__).parent)  # doctest: +SKIP
    re.compile('(?s:/(?:.+/)?tests)\\Z')
    """
    if relative_to:

        def prefix(pattern):
            return str((relative_to / pattern).resolve())

        patterns = tuple(
            pattern if pattern.startswith("/") else prefix(pattern)
            for pattern in patterns
        )

    if len(patterns) == 0:
        return None
    translated = (
        glob_translate(pattern, recursive=True, include_hidden=True)
        for pattern in patterns
    )
    joined = "|".join(translated)
    regex = re.compile(f"{joined}")
    return regex


def _walk_source_package(path, *, ignore_regex):
    """Iterate source files in a Python package.

    .. note::
        Inner function of :func:`walk_source_package`. See that function
        for more details.

    Parameters
    ----------
    path : Path
        Root directory of a Python package. Can also be a single Python or stub
        file.
    ignore_regex : re.Pattern
        Don't yield files matching this regex-compiled glob-like pattern.

    Yields
    ------
    source_path : Path
        Either a Python file or a stub file that takes precedence.
    """
    # Make sure
    if ignore_regex and ignore_regex.match(str(path.resolve())):
        logger.info("Ignoring '%s'", path)
        return

    if is_python_package_dir(path):
        for sub_path in path.iterdir():
            yield from _walk_source_package(sub_path, ignore_regex=ignore_regex)

    elif is_python_or_stub_file(path):
        stub_path = path.with_suffix(".pyi")
        # We check if a corresponding stub exists (even if  `path` is a stub),
        # one that isn't generated by docstub itself
        is_valid_stub = stub_path.is_file() and not is_docstub_generated(stub_path)

        if path != stub_path and not is_valid_stub:
            # `path` isn't stub and no a stub exists that should take precedence
            yield path
        elif path == stub_path and is_valid_stub:
            # `path` is stub and not generated by docstub
            yield path

    elif path.is_dir():
        logger.debug("Skipping directory '%s', not a Python package", path)

    elif path.is_file():
        logger.debug("Skipping non-Python file '%s'", path)


def walk_source_package(path, *, ignore=()):
    """Iterate over a source package for docstub.

    Given a Python package, yield the path of contained Python modules. If an
    alternate stub file already exists and isn't generated by docstub, it is
    returned instead.

    Parameters
    ----------
    path : Path
        A Python package, either a directory or a single file.
    ignore : Sequence[str], optional
        Don't yield files matching these glob-like patterns. The pattern is
        interpreted relative to the root of the Python package unless it starts
        with "/". See :ref:`glob.translate(..., recursive=True, include_hidden=True)`
        for more details on the precise implementation.

    Yields
    ------
    source_path : Path
        Either a Python file or a stub file that takes precedence. Note that
        stub files generated by docstub itself are not returned.

    Raises
    ------
    TypeError
        If `path` is not a valid Python package. Note that a single
        Python file is considered a "package".

    See Also
    --------
    walk_source_and_targets

    Examples
    --------
    >>> from pathlib import Path
    >>> this_file = Path(__file__)

    Walk `path` to current file
    >>> package_files = sorted(walk_source_package(this_file))
    >>> len(package_files)
    1
    >>> package_files[0].as_posix()
    '.../docstub/_path_utils.py'

    Walk `path` to directory of current file
    >>> package_files = walk_source_package(this_file.parent)
    >>> sorted(package_files)
    [.../docstub/__init__.py'), ...]

    Ignoring all files ending with '.py' will return nothing
    >>> next(walk_source_package(this_file.parent, ignore=("*.py")))
    Traceback (most recent call last):
        ...
    StopIteration
    """
    if not is_python_package_dir(path) and not is_python_or_stub_file(path):
        raise TypeError(f"{path} must be a Python file or package")

    regex = glob_patterns_to_regex(tuple(ignore), relative_to=path)

    if is_python_or_stub_file(path):
        stub_file = path.with_suffix(".pyi")
        if (
            stub_file != path
            and stub_file.is_file()
            and not is_docstub_generated(stub_file)
        ):
            # Special case: `path` is a Python file for which a stub file
            # exists, we want to return that one while taking into account
            # `ignore` and other logic. A simple way to do so is to just pass
            # the stub file instead of `path`.
            path = stub_file

    yield from _walk_source_package(path, ignore_regex=regex)


def walk_source_and_targets(root_path, target_dir, *, ignore=()):
    """Iterate modules in a Python package and its target stub files.

    Parameters
    ----------
    root_path : Path
        Root directory of a Python package or a single Python file.
    target_dir : Path
        Root directory in which a matching stub package will be created.
    ignore : Sequence[str], optional
        Don't yield files matching these glob-like patterns. The pattern is
        interpreted relative to the root of the Python package unless it starts
        with "/". See :ref:`glob.translate(..., recursive=True, include_hidden=True)`
        for more details on the precise implementation.

    Yields
    ------
    source_path : Path
        Either a Python file or a stub file that takes precedence.
    stub_path : Path
        Target stub file.

    Raises
    ------
    TypeError
        If `root_path` is not a valid Python package. Note that a single
        Python file is considered a "package".

    See Also
    --------
    walk_source_package

    Examples
    --------
    >>> from pathlib import Path
    >>> current_root = Path(__file__).parent
    >>> sources_n_targets = sorted(
    ...     walk_source_and_targets(current_root, target_dir=current_root)
    ... )
    >>> source_path, stub_path = sources_n_targets[0]
    >>> source_path.as_posix()
    '.../docstub/__init__.py'
    >>> stub_path.as_posix()
    '.../docstub/__init__.pyi'
    >>> stub_path.is_file()
    False
    """
    if root_path.is_file():
        stub_path = target_dir / root_path.with_suffix(".pyi").name
        yield root_path, stub_path
        return

    for source_path in walk_source_package(root_path, ignore=ignore):
        stub_path = target_dir / source_path.with_suffix(".pyi").relative_to(root_path)
        yield source_path, stub_path
