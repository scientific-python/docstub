# File generated with docstub

import enum
import keyword
import logging
from collections.abc import Generator, Iterable, Sequence
from dataclasses import dataclass
from pathlib import Path
from textwrap import indent
from typing import Any, Final, Self

import lark
import lark.visitors
from _typeshed import Incomplete

from ._report import ContextReporter
from ._utils import DocstubError

logger: Final[logging.Logger]

grammar_path: Final[Path]

with grammar_path.open() as file:
    _grammar: Final[str]

_lark: Final[lark.Lark]

def flatten_recursive(iterable: Iterable[Iterable | str]) -> Generator[str]: ...
def insert_between(iterable: Iterable, *, sep: Any) -> list[Any]: ...

class TermKind(enum.StrEnum):

    NAME = enum.auto()
    LITERAL = enum.auto()
    SYNTAX = enum.auto()

class Term(str):
    kind: TermKind
    pos: tuple[int, int] | None

    __slots__: Final[tuple[str, ...]]

    def __new__(
        cls, value: str, *, kind: TermKind | str, pos: tuple[int, int] | None = ...
    ) -> Self: ...
    def __repr__(self) -> str: ...
    def __getnewargs_ex__(self) -> tuple[tuple[Any, ...], dict[str, Any]]: ...

@dataclass(slots=True)
class Expr:

    rule: str
    children: list[Self | Term]

    @property
    def terms(self) -> list[Term]: ...
    @property
    def names(self) -> list[Term]: ...
    @property
    def sub_expressions(self) -> list[Self]: ...
    def __iter__(self) -> Generator[Expr | Term]: ...
    def format_tree(self) -> str: ...
    def print_tree(self) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def as_code(self) -> str: ...

BLACKLISTED_QUALNAMES: Final[set[str]]

class BlacklistedQualname(DocstubError):
    pass

class DoctypeTransformer(lark.visitors.Transformer):
    def __init__(self, *, reporter: ContextReporter | None = ...) -> None: ...
    def start(self, tree: lark.Tree) -> Expr: ...
    def qualname(self, tree: lark.Tree) -> Term: ...
    def rst_role(self, tree: lark.Tree) -> Expr: ...
    def ELLIPSES(self, token: lark.Token) -> Term: ...
    def union(self, tree: lark.Tree) -> Expr: ...
    def subscription(self, tree: lark.Tree) -> Expr: ...
    def param_spec(self, tree: lark.Tree) -> Expr: ...
    def callable(self, tree: lark.Tree) -> Expr: ...
    def literal(self, tree: lark.Tree) -> Expr: ...
    def natlang_literal(self, tree: lark.Tree) -> Expr: ...
    def literal_item(self, tree: lark.Tree) -> Term: ...
    def natlang_container(self, tree: lark.Tree) -> Expr: ...
    def natlang_array(self, tree: lark.Tree) -> Expr: ...
    def array_name(self, tree: lark.Tree) -> Term: ...
    def dtype(self, tree: lark.Tree) -> Expr: ...
    def shape(self, tree: lark.Tree) -> lark.visitors._DiscardType: ...
    def optional_info(self, tree: lark.Tree) -> lark.visitors._DiscardType: ...
    def extra_info(self, tree: lark.Tree) -> lark.visitors._DiscardType: ...
    def _format_subscription(self, sequence: Sequence[str], *, rule: str) -> Expr: ...

def parse_doctype(doctype: str, *, reporter: ContextReporter | None = ...) -> Expr: ...
